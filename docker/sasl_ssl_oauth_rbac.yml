x-kafka-env:
  &kafka-env
  CLUSTER_ID: vHCgQyIrRHG8Jv27qI2h3Q
  KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: CONTROLLER:SSL,INTERNAL:SASL_SSL,EXTERNAL:SASL_SSL,TOKEN:SASL_SSL
  KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER
  KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
  KAFKA_PROCESS_ROLES: broker,controller
  KAFKA_CONTROLLER_QUORUM_VOTERS: 1@broker1:19091,2@broker2:19091,3@broker3:19091

  # Logging
  KAFKA_LOG_RETENTION_HOURS: '1'
  KAFKA_LOG_RETENTION_CHECK_INTERVAL_MS: 300000
  KAFKA_LOG_SEGMENT_BYTES: 1073741824
  KAFKA_LOG_DIRS: /tmp/kraft-combined-logs
  KAFKA_LOG4J_ROOT_LOGLEVEL: INFO # DEBUG
  KAFKA_LOG4J_LOGGERS: "kafka.authorizer.logger=INFO,io.confluent.rest-utils=INFO,io.confluent.rbacapi=INFO,io.confluent.tokenapi=INFO,io.confluent.security.auth=INFO,io.confluent.security.store=INFO,io.confluent.common.security.jetty=INFO"

  # Authentication
  KAFKA_SASL_ENABLED_MECHANISMS: OAUTHBEARER
#    KAFKA_SASL_MECHANISM_CONTROLLER_PROTOCOL: OAUTHBEARER
  KAFKA_SASL_MECHANISM_INTER_BROKER_PROTOCOL: OAUTHBEARER
  KAFKA_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
  KAFKA_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
  KAFKA_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
  KAFKA_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
  KAFKA_SASL_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_SASL_OAUTHBEARER_SCOPE_CLAIM_NAME: scope
  KAFKA_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
  KAFKA_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
  KAFKA_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler
  KAFKA_SUPER_USERS: User:${SUPERUSER_CLIENT_ID};User:${SSO_CLIENT_ID};User:broker2;User:broker3
  KAFKA_BROKER_USERS: User:${SUPERUSER_CLIENT_ID};User:broker2;User:broker3

  # Authorizer
  KAFKA_AUTHORIZER_CLASS_NAME: io.confluent.kafka.security.authorizer.ConfluentServerAuthorizer # kafka.security.authorizer.AclAuthorizer
  KAFKA_CONFLUENT_AUTHORIZER_ACCESS_RULE_PROVIDERS: CONFLUENT,KRAFT_ACL
  KAFKA_CONFLUENT_OPERATOR_MANAGED: 'true'
  KAFKA_CONFLUENT_OAUTH_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
  KAFKA_CONFLUENT_AUTHORIZER_GROUP_PROVIDER: RBAC
  KAFKA_CONFIG_PROVIDERS: file
  KAFKA_CONFIG_PROVIDERS_FILE_CLASS: org.apache.kafka.common.config.provider.FileConfigProvider

  # encryption
  KAFKA_SSL_ENABLED_PROTOCOLS: TLSv1.2
  KAFKA_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'https'
  KAFKA_SSL_CLIENT_AUTH: 'required'
  KAFKA_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_SSL_KEYSTORE_FILENAME: keystore.p12
  KAFKA_SSL_KEYSTORE_CREDENTIALS: creds.txt
  KAFKA_SSL_KEY_CREDENTIALS: creds.txt
  KAFKA_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_SSL_TRUSTSTORE_FILENAME: truststore.p12
  KAFKA_SSL_TRUSTSTORE_CREDENTIALS: creds.txt
  KAFKA_SSL_CIPHER_SUITES: ${SSL_CIPHER_SUITES}
  KAFKA_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # Internal Listener
  KAFKA_LISTENER_NAME_INTERNAL_SASL_ENABLED_MECHANISMS: OAUTHBEARER
#  KAFKA_LISTENER_NAME_INTERNAL_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
  KAFKA_LISTENER_NAME_INTERNAL_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
  KAFKA_LISTENER_NAME_INTERNAL_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
  KAFKA_LISTENER_NAME_INTERNAL_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
  KAFKA_LISTENER_NAME_INTERNAL_SASL_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_LISTENER_NAME_INTERNAL_SASL_OAUTHBEARER_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
#      ssl.endpoint.identification.algorithm="https" \
#      ssl.keystore.type="PKCS12" \
#      ssl.keystore.location="/etc/kafka/secrets/keystore.p12" \
#      ssl.keystore.password="${CERT_SECRET}" \
#      ssl.key.password="${CERT_SECRET}"  \
  KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_JAAS_CONFIG: |
    org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
        oauth.client.id="${SUPERUSER_CLIENT_ID}" \
        oauth.client.secret="${SUPERUSER_CLIENT_SECRET}" \
        oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
        principalClaimName="sub" \
        refresh_ms="3000" \
        ssl.truststore.type="PKCS12" \
        ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
        ssl.truststore.password="${CERT_SECRET}";
  KAFKA_LISTENER_NAME_INTERNAL_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
  KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
  KAFKA_LISTENER_NAME_INTERNAL_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler

  KAFKA_LISTENER_NAME_INTERNAL_SSL_CLIENT_AUTH: 'required'
  KAFKA_LISTENER_NAME_INTERNAL_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'https'
  KAFKA_LISTENER_NAME_INTERNAL_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_INTERNAL_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_LISTENER_NAME_INTERNAL_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_INTERNAL_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_INTERNAL_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_INTERNAL_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_LISTENER_NAME_INTERNAL_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_INTERNAL_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # Controller Listener
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_CLIENT_AUTH: 'required'
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'https'
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_CONTROLLER_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # External OAuth (Keycloak)
  KAFKA_LISTENER_NAME_EXTERNAL_SASL_ENABLED_MECHANISMS: OAUTHBEARER
  KAFKA_LISTENER_NAME_EXTERNAL_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
  KAFKA_LISTENER_NAME_EXTERNAL_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
  KAFKA_LISTENER_NAME_EXTERNAL_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
  KAFKA_LISTENER_NAME_EXTERNAL_SASL_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_LISTENER_NAME_EXTERNAL_SASL_OAUTHBEARER_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
#      ssl.endpoint.identification.algorithm="https" \
#      ssl.keystore.type="PKCS12" \
#      ssl.keystore.location="/etc/kafka/secrets/keystore.p12" \
#      ssl.keystore.password="${CERT_SECRET}" \
#      ssl.key.password="${CERT_SECRET}"  \
  KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_JAAS_CONFIG: |
    org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
        oauth.client.id="${CLIENT_APP_ID}" \
        oauth.client.secret="${CLIENT_APP_SECRET}" \
        oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
        principalClaimName="sub" \
        refresh_ms="3000" \
        ssl.truststore.type="PKCS12" \
        ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
        ssl.truststore.password="${CERT_SECRET}";
  KAFKA_LISTENER_NAME_EXTERNAL_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
  KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
  KAFKA_LISTENER_NAME_EXTERNAL_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler

  KAFKA_LISTENER_NAME_EXTERNAL_SSL_CLIENT_AUTH: 'required'
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'https'
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_EXTERNAL_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # Token Listener
  KAFKA_LISTENER_NAME_TOKEN_SASL_ENABLED_MECHANISMS: OAUTHBEARER
#  refresh_ms="3000" \
#  ssl.truststore.type="PKCS12" \
#  ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
#  ssl.truststore.password="${CERT_SECRET}";
  KAFKA_LISTENER_NAME_TOKEN_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
  KAFKA_LISTENER_NAME_TOKEN_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
  KAFKA_LISTENER_NAME_TOKEN_SASL_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_LISTENER_NAME_TOKEN_OAUTHBEARER_SASL_JAAS_CONFIG: |
    org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
        publicKeyPath="/tmp/conf/public.pem" \
        scope="${GROUP_CLAIM_NAME}";
  KAFKA_LISTENER_NAME_TOKEN_PRINCIPAL_BUILDER_CLASS: io.confluent.kafka.security.authenticator.OAuthKafkaPrincipalBuilder
  KAFKA_LISTENER_NAME_TOKEN_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.confluent.kafka.server.plugins.auth.token.TokenBearerServerLoginCallbackHandler
  KAFKA_LISTENER_NAME_TOKEN_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.confluent.kafka.server.plugins.auth.token.TokenBearerValidatorCallbackHandler

  KAFKA_LISTENER_NAME_TOKEN_SSL_CLIENT_AUTH: 'required'
  KAFKA_LISTENER_NAME_TOKEN_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'https'
  KAFKA_LISTENER_NAME_TOKEN_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_TOKEN_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_LISTENER_NAME_TOKEN_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_TOKEN_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_TOKEN_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_LISTENER_NAME_TOKEN_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_LISTENER_NAME_TOKEN_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_LISTENER_NAME_TOKEN_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # MDS (if enabled)
  KAFKA_CONFLUENT_METADATA_SERVER_ENABLED: 'true'
  KAFKA_CONFLUENT_METADATA_SERVER_OPENAPI_ENABLE: 'true'
  KAFKA_CONFLUENT_METADATA_SERVER_ENABLE_SERVERS_URLS_REFRESH: 'true'
  KAFKA_CONFLUENT_METADATA_SERVER_AUTHENTICATION_METHOD: BEARER
  KAFKA_CONFLUENT_METADATA_SERVER_IMPERSONATION_SUPER_USERS: User:${SSO_CLIENT_ID};User:${SUPERUSER_CLIENT_ID};User:broker2;User:broker3
  KAFKA_CONFLUENT_METADATA_SERVER_LISTENERS: https://0.0.0.0:8091
  KAFKA_CONFLUENT_METADATA_TOPIC_REPLICATION_FACTOR: 3 # = broker count
  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
#  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_LOGIN_CLIENT_ID: ${SUPERUSER_CLIENT_ID}
#  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_LOGIN_CLIENT_SECRET: ${SUPERUSER_CLIENT_SECRET}
#  KAFKA_CONFLUENT_METADATA_SERVER_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
#  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
#  KAFKA_CONFLUENT_METADATA_SERVER_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler

  KAFKA_CONFLUENT_METADATA_SERVER_SSO_MODE: 'oidc'
  KAFKA_CONFLUENT_METADATA_SERVER_TOKEN_AUTH_ENABLE: 'true'
  KAFKA_CONFLUENT_METADATA_SERVER_TOKEN_MAX_LIFETIME_MS: 3600000
  KAFKA_CONFLUENT_METADATA_SERVER_TOKEN_SIGNATURE_ALGORITHM: RS256
  KAFKA_CONFLUENT_METADATA_SERVER_USER_STORE: OAUTH
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_CLIENT_AUTHENTICATION: 'NONE' # REQUIRED
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'HTTPS'
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_CIPHER_SUITES: ${SSL_CIPHER_SUITES}
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_RELOAD: 'true'
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_METADATA_SERVER_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT
  KAFKA_CONFLUENT_METADATA_SERVER_PUBLIC_KEY_PATH: /tmp/conf/public.pem
  KAFKA_CONFLUENT_METADATA_SERVER_TOKEN_KEY_PATH: /tmp/conf/keypair.pem

  # Rest client
  KAFKA_KAFKA_REST_BOOTSTRAP_SERVERS: SASL_SSL://broker1:49091,SASL_SSL://broker2:49091,SASL_SSL://broker3:49091
  KAFKA_KAFKA_REST_CLIENT_SECURITY_PROTOCOL: SASL_SSL
#  KAFKA_KAFKA_REST_CLIENT_SASL_MECHANISM: OAUTHBEARER
#  KAFKA_KAFKA_REST_CLIENT_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
#      KAFKA_KAFKA_REST_CLIENT_OAUTHBEARER_SASL_JAAS_CONFIG: |
#        org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
#            oauth.client.id="${RP_CLIENT_ID}" \
#            oauth.client.secret="${RP_CLIENT_SECRET}" \
#            oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
#            principalClaimName="sub" \
#            refresh_ms="3000" \
#            ssl.endpoint.identification.algorithm="https" \
#            ssl.keystore.type="PKCS12" \
#            ssl.keystore.location="/etc/kafka/secrets/keystore.p12" \
#            ssl.keystore.password="${CERT_SECRET}" \
#            ssl.key.password="${CERT_SECRET}"  \
#            ssl.truststore.type="PKCS12" \
#            ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
#            ssl.truststore.password="${CERT_SECRET}";
#  KAFKA_KAFKA_REST_CLIENT_OAUTHBEARER_SASL_JAAS_CONFIG: |
#    org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
#      metadataServerUrls="https://broker1:8091,https://broker2:8091,https://broker3:8091" \
#      username="${RP_CLIENT_ID}" \
#      password="${RP_CLIENT_SECRET}" \
#      ssl.truststore.type="PKCS12" \
#      ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
#      ssl.truststore.password="${CERT_SECRET}";
#  KAFKA_KAFKA_REST_CLIENT_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
#  KAFKA_KAFKA_REST_CLIENT_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
#  KAFKA_KAFKA_REST_CLIENT_PRINCIPAL_BUILDER_CLASS: io.confluent.kafka.security.authenticator.OAuthKafkaPrincipalBuilder
#  KAFKA_KAFKA_REST_CLIENT_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.confluent.kafka.server.plugins.auth.token.TokenBearerServerLoginCallbackHandler

  KAFKA_KAFKA_REST_CLIENT_CONFLUENT_METADATA_SERVER_URLS_MAX_AGE_MS: 60000
#  KAFKA_KAFKA_REST_CLIENT_SSL_CLIENT_AUTHENTICATION: 'REQUIRED'
#  KAFKA_KAFKA_REST_CLIENT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'HTTPS'
  KAFKA_KAFKA_REST_CLIENT_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_KAFKA_REST_CLIENT_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_KAFKA_REST_CLIENT_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_CLIENT_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_CLIENT_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_KAFKA_REST_CLIENT_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_KAFKA_REST_CLIENT_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_CLIENT_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # EmbeddedKafkaRest
  KAFKA_KAFKA_REST_ENABLE: 'true'
  KAFKA_KAFKA_REST_SCHEMA_REGISTRY_URL: https://schema-registry1:8081
#    KAFKA_KAFKA_REST_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
#    KAFKA_KAFKA_REST_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
#    KAFKA_KAFKA_REST_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
#    KAFKA_KAFKA_REST_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
#    KAFKA_KAFKA_REST_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
#    KAFKA_KAFKA_REST_OAUTHBEARER_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
#  KAFKA_KAFKA_REST_OAUTHBEARER_LOGIN_CLIENT_ID: ${RP_CLIENT_ID}
#  KAFKA_KAFKA_REST_OAUTHBEARER_LOGIN_CLIENT_SECRET: ${RP_CLIENT_SECRET}
#      ssl.endpoint.identification.algorithm="https" \
#      ssl.keystore.type="PKCS12" \
#      ssl.keystore.location="/etc/kafka/secrets/keystore.p12" \
#      ssl.keystore.password="${CERT_SECRET}" \
#      ssl.key.password="${CERT_SECRET}"  \
#  KAFKA_KAFKA_REST_OAUTHBEARER_SASL_JAAS_CONFIG: |
#    org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
#        oauth.client.id="${RP_CLIENT_ID}" \
#        oauth.client.secret="${RP_CLIENT_SECRET}" \
#        oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
#        principalClaimName="sub" \
#        refresh_ms="3000" \
#        ssl.truststore.type="PKCS12" \
#        ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
#        ssl.truststore.password="${CERT_SECRET}";
#  KAFKA_KAFKA_REST_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
#  KAFKA_KAFKA_REST_OAUTHBEARER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
#    KAFKA_KAFKA_REST_OAUTHBEARER_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler

  KAFKA_KAFKA_REST_PUBLIC_KEY_PATH: /tmp/conf/public.pem
  KAFKA_KAFKA_REST_KAFKA_REST_RESOURCE_EXTENSION_CLASS: io.confluent.kafkarest.security.KafkaRestSecurityResourceExtension
  KAFKA_KAFKA_REST_REST_SERVLET_INITALIZOR_CLASSES: io.confluent.common.security.jetty.initializer.AuthenticationHandler
  KAFKA_KAFKA_REST_SSL_CLIENT_AUTHENTICATION: 'REQUIRED'
  KAFKA_KAFKA_REST_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'HTTPS'
  KAFKA_KAFKA_REST_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_KAFKA_REST_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_KAFKA_REST_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_KAFKA_REST_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_KAFKA_REST_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # EmbeddedKafkaRest: MDS Client configuration
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_ENABLE_SERVER_URLS_REFRESH: 'true'
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_BOOTSTRAP_SERVER_URLS: https://broker1:8091,https://broker2:8091,https://broker3:8091
#  KAFKA_KAFKA_REST_CONFLUENT_METADATA_HTTP_AUTH_CREDENTIALS_PROVIDER: OAUTHBEARER
#  KAFKA_KAFKA_REST_CONFLUENT_METADATA_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
#  KAFKA_KAFKA_REST_CONFLUENT_METADATA_OAUTHBEARER_LOGIN_CLIENT_ID: ${RP_CLIENT_ID}
#  KAFKA_KAFKA_REST_CONFLUENT_METADATA_OAUTHBEARER_LOGIN_CLIENT_SECRET: ${RP_CLIENT_SECRET}

  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_URLS_MAX_AGE_MS: 60000
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SERVER_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_KAFKA_REST_CONFLUENT_METADATA_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # metrics reporter
#    KAFKA_JMX_PORT: 9101
#    KAFKA_JMX_HOSTNAME: localhost
#    KAFKA_JMX_OPTS: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=broker1 -Dcom.sun.management.jmxremote.rmi.port=9101
  KAFKA_CONFLUENT_METRICS_ENABLE: 'true'
  KAFKA_METRIC_REPORTERS: io.confluent.metrics.reporter.ConfluentMetricsReporter
  KAFKA_CONFLUENT_METRICS_REPORTER_BOOTSTRAP_SERVERS: broker1:29091,broker2:29091,broker3:29091
  KAFKA_CONFLUENT_METRICS_REPORTER_TOPIC_REPLICAS: 3 # = broker count
  KAFKA_CONFLUENT_METRICS_REPORTER_PUBLISH_MS: 30000
  KAFKA_CONFLUENT_METRICS_REPORTER_SECURITY_PROTOCOL: SASL_SSL
  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_MECHANISM: OAUTHBEARER
#  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
#  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
#  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
#  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
#  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
#  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_OAUTHBEARER_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
#    ssl.endpoint.identification.algorithm="https" \
#    ssl.keystore.type="PKCS12" \
#    ssl.keystore.location="/etc/kafka/secrets/keystore.p12" \
#    ssl.keystore.password="${CERT_SECRET}" \
#    ssl.key.password="${CERT_SECRET}"  \
  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_JAAS_CONFIG: |
    org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
        oauth.client.id="${SUPERUSER_CLIENT_ID}" \
        oauth.client.secret="${SUPERUSER_CLIENT_SECRET}" \
        oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
        principalClaimName="sub" \
        refresh_ms="3000" \
        ssl.truststore.type="PKCS12" \
        ssl.truststore.location="/etc/kafka/secrets/truststore.p12" \
        ssl.truststore.password="${CERT_SECRET}";
  KAFKA_CONFLUENT_METRICS_REPORTER_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
  KAFKA_CONFLUENT_METRICS_REPORTER_SASL_SERVER_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.server.JaasServerOauthValidatorCallbackHandler

#  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_CLIENT_AUTH: 'required'
#  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM: 'https'
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_METRICS_REPORTER_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # schema validation
  KAFKA_CONFLUENT_SCHEMA_REGISTRY_URL: https://schema-registry1:8081
  KAFKA_CONFLUENT_BEARER_AUTH_CLIENT_ID: ${SUPERUSER_CLIENT_ID}
  KAFKA_CONFLUENT_BEARER_AUTH_CLIENT_SECRET: ${SUPERUSER_CLIENT_SECRET}
  KAFKA_CONFLUENT_BEARER_AUTH_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_CONFLUENT_BEARER_AUTH_ISSUER_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
  KAFKA_CONFLUENT_BEARER_AUTH_CREDENTIALS_SOURCE: OAUTHBEARER
  KAFKA_CONFLUENT_BEARER_AUTH_SCOPE: profile
  KAFKA_CONFLUENT_SSL_KEYSTORE_TYPE: PKCS12
  KAFKA_CONFLUENT_SSL_KEYSTORE_LOCATION: /etc/kafka/secrets/keystore.p12
  KAFKA_CONFLUENT_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_SSL_KEY_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_SSL_TRUSTSTORE_TYPE: PKCS12
  KAFKA_CONFLUENT_SSL_TRUSTSTORE_LOCATION: /etc/kafka/secrets/truststore.p12
  KAFKA_CONFLUENT_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
  KAFKA_CONFLUENT_SSL_PRINCIPAL_MAPPING_RULES: RULE:^CN=([a-zA-Z0-9]*).*$$/$$1/L,DEFAULT

  # Enable SSO for Control Center
  KAFKA_CONFLUENT_OIDC_IDP_REFRESH_TOKEN_ENABLED: 'true'
  KAFKA_CONFLUENT_OIDC_IDP_JWKS_ENDPOINT_URI: ${IDP_JWKS_ENDPOINT}
  KAFKA_CONFLUENT_OIDC_IDP_TOKEN_BASE_ENDPOINT_URI: ${IDP_TOKEN_ENDPOINT}
  KAFKA_CONFLUENT_OIDC_IDP_AUTHORIZE_BASE_ENDPOINT_URI: ${IDP_AUTH_ENDPOINT}
  KAFKA_CONFLUENT_OIDC_IDP_DEVICE_AUTHORIZATION_ENDPOINT_URI: ${IDP_DEVICE_AUTH_ENDPOINT}
  KAFKA_CONFLUENT_OIDC_IDP_ISSUER: ${IDP_EXPECTED_ISSUER}
  KAFKA_CONFLUENT_OIDC_IDP_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
  KAFKA_CONFLUENT_OIDC_IDP_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
  KAFKA_CONFLUENT_OIDC_IDP_CLIENT_ID: ${SSO_CLIENT_ID}
  KAFKA_CONFLUENT_OIDC_IDP_CLIENT_SECRET: ${SSO_CLIENT_SECRET}
  KAFKA_CONFLUENT_OIDC_SESSION_MAX_TIMEOUT_MS: 21600000
  KAFKA_CONFLUENT_OIDC_SESSION_TOKEN_EXPIRY_MS: 90000

  # Balancer
  KAFKA_AUTO_CREATE_TOPICS_ENABLED: 'true'
  KAFKA_DELETE_TOPIC_ENABLED: 'true'
  KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
  KAFKA_GROUP_MAX_SESSION_TIMEOUT_MS: 300000      # 5 mins
  KAFKA_DEFAULT_REPLICATION_FACTOR: 3             # 3 brokers
  KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 2          # Đảm bảo có quorum (n - 1) brokers sẵn sàng
  KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 3

  KAFKA_MIN_INSYNC_REPLICAS: 2                  # Nên >= 2 khi replication = 3 (tối thiểu 2 replicas sống)
  KAFKA_REPLICA_LAG_TIME_MAX_MS: 30000            # 30s là hợp lý cho phát hiện lag

  KAFKA_NUM_IO_THREADS: 8                       # Tùy thuộc CPU (thường = số vCPU)
  KAFKA_NUM_NETWORK_THREADS: 3                  # Một cho mỗi broker là đủ (hoặc = số NIC)
  KAFKA_NUM_RECOVERY_THREADS_PER_DATA_DIR: 2    # Nếu bạn dùng 1 ổ đĩa: để = 2 giúp phục hồi nhanh hơn

  KAFKA_OFFSETS_COMMIT_TIMEOUT_MS: 10000          # 10s
  KAFKA_OFFSETS_RETENTION_MINUTES: 10080          # 7 days
  KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 3
  KAFKA_OFFSETS_TOPIC_COMPRESSION_CODEC: 1      # gzip

  KAFKA_CONFLUENT_LICENSE_TOPIC_REPLICATION_FACTOR: 3
  KAFKA_CONFLUENT_BALANCER_TOPIC_REPLICATION_FACTOR: 3
  KAFKA_CONFLUENT_CLUSTER_LINK_METADATA_TOPIC_REPLICATION_FACTOR: 3

  KAFKA_CONFLUENT_BALANCER_ENABLED: 'true'
  KAFKA_CONFLUENT_TELEMETRY_ENABLED: 'false'
  KAFKA_CONFLUENT_REPORTERS_TELEMETRY_AUTO_ENABLED: 'false'
  KAFKA_CONFLUENT_SECURITY_EVENT_LOGGER_AUTHENTICATION_ENABLE: 'true'

#    EXTRA_ARGS: "-javaagent:/usr/bin/jmx/jmx_prometheus_javaagent.jar=1234:/usr/bin/jmx/exporter.yml"
#      -Djava.security.auth.login.config=/etc/kafka/kafka_server_jaas.conf
  KAFKA_OPTS: |
    -Djavax.net.ssl.trustStore=/etc/kafka/secrets/truststore.p12
    -Djavax.net.ssl.trustStorePassword=${CERT_SECRET}
    -Doauth.jwks.endpoint.uri=${IDP_JWKS_ENDPOINT}
    -Doauth.valid.issuer.uri=${IDP_EXPECTED_ISSUER}
    -Doauth.username.claim=${SUB_CLAIM_NAME}
    -Dorg.apache.kafka.sasl.oauthbearer.allowed.urls=${IDP_JWKS_ENDPOINT},${IDP_TOKEN_ENDPOINT},${IDP_AUTH_ENDPOINT},${IDP_DEVICE_AUTH_ENDPOINT}
  KAFKA_HEAP_OPTS: "-Xms${BROKER_HEAP} -Xmx${BROKER_HEAP}"

services:
    # --------- Postgres ---------
#  postgres:
#    #    build:
#    #      context: ./postgres
#    #      args:
#    #        POSTGRES_DOCKER_TAG: ${POSTGRES_DOCKER_TAG:-latest}
#    image: postgres:${POSTGRES_DOCKER_TAG:-latest}
#    container_name: postgres
#    ports:
#      - "5432:5432"
#    networks:
#      - my-network
#    command: postgres -c 'max_connections=500'
#    healthcheck:
#      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d postgres" ]
#      interval: 30s
#      timeout: 10s
#      start_period: 30s
#      retries: 3
#    restart: always
#    volumes:
#      - ./postgres/init-db:/docker-entrypoint-initdb.d:ro
#      - postgres-data:/var/lib/postgresql/data
#    environment:
#      POSTGRES_USER: ${POSTGRES_USER}
#      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
#
#  quarkus_certgen:
#    build: ./
#    container_name: quarkus_certgen
#    networks:
#      - my-network
#    entrypoint: [ "sh", "/app/generate_cert.sh" ]
#    restart: no
#    volumes:
#      - ./scripts/helper/generate_cert.sh:/app/generate_cert.sh
#      - ./certs/ca:/ca
#      - ../src/adapter/src/main/resources/certs:/quarkus
#    environment:
#      - MAIN_DOMAIN=quarkus
#      - CERT_PASSWORD=${CERT_SECRET}
#
#  keycloak_certgen:
#    build: ./
#    container_name: keycloak_certgen
#    networks:
#      - my-network
#    entrypoint: [ "sh", "/app/generate_cert.sh" ]
#    restart: no
#    volumes:
#      - ./scripts/helper/generate_cert.sh:/app/generate_cert.sh
#      - ./certs/ca:/ca
#      - ./keycloak/certs:/keycloak
#    environment:
#      - MAIN_DOMAIN=keycloak
#      - CERT_PASSWORD=${CERT_SECRET}
#
#  # --------- Keycloak ---------
#  keycloak:
#    image: quay.io/keycloak/keycloak:${KEYCLOAK_DOCKER_TAG:-latest}
#    #    build:
#    #      context: ./keycloak
#    #      args:
#    #        KEYCLOAK_DOCKER_TAG: ${KEYCLOAK_DOCKER_TAG:-latest}
#    container_name: keycloak
#    depends_on:
#      postgres:
#        condition: service_healthy
#      keycloak_certgen:
#        condition: service_completed_successfully
#    ports:
#      - "8443:8443" # HTTPS
#      - "9990:9990" # Management port
#    networks:
#      - my-network
#    command: [
#      "start",
#      "--https-certificate-file=/opt/keycloak/conf/cert.pem",
#      "--https-certificate-key-file=/opt/keycloak/conf/key.pem",
#      "--http-enabled=false",
#      "--https-port=8443",
#      "--hostname-strict=false",
#      "--health-enabled=true",
#      "--import-realm"
#    ]
#    #    healthcheck:
#    #      test: [ "CMD-SHELL", "exec 3<>/dev/tcp/127.0.0.1/9990; echo -e 'GET /health/ready HTTP/1.1\r\nHost: localhost:9990\r\nConnection: close\r\n\r\n' >&3; cat <&3 | grep -q '\"status\": \"UP\"' && exit 0 || exit 1" ]
#    #      interval: 30s
#    #      timeout: 10s
#    #      start_period: 30s
#    #      retries: 3
#    restart: always
#    volumes:
#      - ./keycloak/realms-import.json:/opt/keycloak/data/import/realms-import.json
#      - ./keycloak/certs/cert.pem:/opt/keycloak/conf/cert.pem:ro
#      - ./keycloak/certs/key.pem:/opt/keycloak/conf/key.pem:ro
#      - ./keycloak/exports:/opt/keycloak/data/export
#    environment:
#      KC_HTTP_MANAGEMENT_PORT: 9990
#      KC_METRICS_ENABLED: true
#      KC_HEALTH_ENABLED: true
#      KC_BOOTSTRAP_ADMIN_USERNAME: ${KC_BOOTSTRAP_ADMIN_USERNAME}
#      KC_BOOTSTRAP_ADMIN_PASSWORD: ${KC_BOOTSTRAP_ADMIN_PASSWORD}
#      KC_PROXY: edge
#      KEYCLOAK_IMPORT: /opt/keycloak/data/import/realms-import.json
#      KC_DB: postgres
#      KC_DB_URL_HOST: postgres
#      KC_DB_URL_PORT: 5432
#      KC_DB_URL_DATABASE: keycloak
#      KC_DB_USERNAME: ${POSTGRES_USER}
#      KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
#
#  wait-for-keycloak:
#    image: curlimages/curl
#    container_name: wait-for-keycloak
#    depends_on:
#      - keycloak
#    networks:
#      - my-network
#    command: >
#      sh -c '
#        i=0;
#        until curl -kfs https://keycloak:9990/health/ready; do
#          echo "Waiting for Keycloak...";
#          sleep 4;
#          i=$$((i+1));
#          if [ $$i -ge 30 ]; then
#            echo "❌ Timeout: Keycloak not ready after 60s.";
#            exit 1;
#          fi;
#        done;
#        echo "✅ Keycloak is ready!"
#      '

  # --------- Kafka Brokers ---------
  keypairgen:
    image: alpine/openssl
    container_name: keypairgen
    networks:
      - my-network
    entrypoint: /bin/sh
    command: "/usr/bin/generate_keypair.sh"
    restart: no
    volumes:
      - ./scripts/helper/generate_keypair.sh:/usr/bin/generate_keypair.sh
      - ./kafka/keypair:/data

  broker1_certgen:
    build: ./
    container_name: broker1_certgen
    networks:
      - my-network
    entrypoint: [ "sh", "/app/generate_cert.sh" ]
    restart: no
    volumes:
      - ./scripts/helper/generate_cert.sh:/app/generate_cert.sh
      - ./certs/ca:/ca
      - ./kafka/broker1/certs:/broker1
    environment:
      - MAIN_DOMAIN=broker1
      - SUB_DOMAINS=broker2;broker3
      - CERT_PASSWORD=${CERT_SECRET}

  broker2_certgen:
    build: ./
    container_name: broker2_certgen
    networks:
      - my-network
    entrypoint: [ "sh", "/app/generate_cert.sh" ]
    restart: no
    volumes:
      - ./scripts/helper/generate_cert.sh:/app/generate_cert.sh
      - ./certs/ca:/ca
      - ./kafka/broker2/certs:/broker2
    environment:
      - MAIN_DOMAIN=broker2
      - SUB_DOMAINS=broker1;broker3
      - CERT_PASSWORD=${CERT_SECRET}

  broker3_certgen:
    build: ./
    container_name: broker3_certgen
    networks:
      - my-network
    entrypoint: [ "sh", "/app/generate_cert.sh" ]
    restart: no
    volumes:
      - ./scripts/helper/generate_cert.sh:/app/generate_cert.sh
      - ./certs/ca:/ca
      - ./kafka/broker3/certs:/broker3
    environment:
      - MAIN_DOMAIN=broker3
      - SUB_DOMAINS=broker1;broker2
      - CERT_PASSWORD=${CERT_SECRET}

  broker1:
    image: confluentinc/cp-server:${CONFLUENT_DOCKER_TAG:-latest}
    container_name: broker1
    depends_on:
#      wait-for-keycloak:
#        condition: service_completed_successfully
      broker1_certgen:
        condition: service_completed_successfully
      keypairgen:
        condition: service_completed_successfully
#      prometheus:
#        condition: service_healthy
    ports:
      - "9101:9101"
      - "39091:39091"
      - "49091:49091"
      - "8091:8091"
      - "1234:1234"
    networks:
      - my-network
    command: "bash -c 'if [ ! -f /tmp/conf/public.pem ]; then echo \"ERROR: Did you forget the create-certificates.sh file that came with this docker-compose.yml file?\" && exit 1 ; else /etc/confluent/docker/run ; fi'"
#    command: ["sh", "-c", "while true; do sleep 3600; done"]
    healthcheck:
      test: [ "CMD", "nc", "-z", "broker1", "8091" ]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 3
    restart: unless-stopped
    volumes:
      - broker1-data:/var/lib/kafka/data
      - ./kafka/keypair:/tmp/conf
      - ./kafka/broker1/certs:/etc/kafka/secrets
      - ./kafka/creds.txt:/etc/kafka/secrets/creds.txt
      - ./kafka/configs:/etc/confluent/configs
      - ./kafka/configs/kafka_server_jaas.conf:/etc/kafka/kafka_server_jaas.conf
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-client-0.15.1.jar
      - ./kafka/bin/confluent:/usr/bin/confluent
      - ./kafka/bin/jmx_prometheus_javaagent.jar:/usr/bin/jmx/jmx_prometheus_javaagent.jar
      - ./kafka/metrics/exporter.yml:/usr/bin/jmx/exporter.yml
    environment:
      << : *kafka-env
      KAFKA_BROKER_ID: '1'
      KAFKA_LISTENERS: CONTROLLER://broker1:19091,INTERNAL://broker1:29091,EXTERNAL://broker1:39091,TOKEN://broker1:49091
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://broker1:29091,EXTERNAL://broker1:39091,TOKEN://broker1:49091
      KAFKA_CONFLUENT_METADATA_SERVER_ADVERTISED_LISTENERS: https://broker1:8091

  broker2:
    image: confluentinc/cp-server:${CONFLUENT_DOCKER_TAG:-latest}
    container_name: broker2
    depends_on:
#      wait-for-keycloak:
#        condition: service_completed_successfully
      broker2_certgen:
        condition: service_completed_successfully
      keypairgen:
        condition: service_completed_successfully
#      prometheus:
#        condition: service_healthy
    ports:
      - "9102:9101"
      - "39092:39091"
      - "49092:49091"
      - "8092:8091"
      - "1235:1234"
    networks:
      - my-network
    command: "bash -c 'if [ ! -f /tmp/conf/public.pem ]; then echo \"ERROR: Did you forget the create-certificates.sh file that came with this docker-compose.yml file?\" && exit 1 ; else /etc/confluent/docker/run ; fi'"
    healthcheck:
      test: [ "CMD", "nc", "-z", "broker2", "8091" ]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 3
    restart: unless-stopped
    volumes:
      - broker2-data:/var/lib/kafka/data
      - ./kafka/keypair:/tmp/conf
      - ./kafka/broker2/certs:/etc/kafka/secrets
      - ./kafka/creds.txt:/etc/kafka/secrets/creds.txt
      - ./kafka/configs:/etc/confluent/configs
      - ./kafka/configs/kafka_server_jaas.conf:/etc/kafka/kafka_server_jaas.conf
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-client-0.15.1.jar
      - ./kafka/bin/confluent:/usr/bin/confluent
      - ./kafka/bin/jmx_prometheus_javaagent.jar:/usr/bin/jmx/jmx_prometheus_javaagent.jar
      - ./kafka/metrics/exporter.yml:/usr/bin/jmx/exporter.yml
    environment:
      <<: *kafka-env
      KAFKA_BROKER_ID: '2'
      KAFKA_LISTENERS: CONTROLLER://broker2:19091,INTERNAL://broker2:29091,EXTERNAL://broker2:39091,TOKEN://broker2:49091
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://broker2:29091,EXTERNAL://broker2:39091,TOKEN://broker2:49091
      KAFKA_CONFLUENT_METADATA_SERVER_ADVERTISED_LISTENERS: https://broker2:8091

  broker3:
    image: confluentinc/cp-server:${CONFLUENT_DOCKER_TAG:-latest}
    container_name: broker3
    depends_on:
#      wait-for-keycloak:
#        condition: service_completed_successfully
      broker2_certgen:
        condition: service_completed_successfully
      keypairgen:
        condition: service_completed_successfully
#      prometheus:
#        condition: service_healthy
    ports:
      - "9103:9101"
      - "39093:39091"
      - "49093:49091"
      - "8093:8091"
      - "1236:1234"
    networks:
      - my-network
    command: "bash -c 'if [ ! -f /tmp/conf/public.pem ]; then echo \"ERROR: Did you forget the create-certificates.sh file that came with this docker-compose.yml file?\" && exit 1 ; else /etc/confluent/docker/run ; fi'"
    healthcheck:
      test: [ "CMD", "nc", "-z", "broker3", "8091" ]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 3
    restart: unless-stopped
    volumes:
      - broker3-data:/var/lib/kafka/data
      - ./kafka/keypair:/tmp/conf
      - ./kafka/broker3/certs:/etc/kafka/secrets
      - ./kafka/creds.txt:/etc/kafka/secrets/creds.txt
      - ./kafka/configs:/etc/confluent/configs
      - ./kafka/configs/kafka_server_jaas.conf:/etc/kafka/kafka_server_jaas.conf
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/kafka/kafka-oauth-client-0.15.1.jar
      - ./kafka/bin/confluent:/usr/bin/confluent
      - ./kafka/bin/jmx_prometheus_javaagent.jar:/usr/bin/jmx/jmx_prometheus_javaagent.jar
      - ./kafka/metrics/exporter.yml:/usr/bin/jmx/exporter.yml
    environment:
      <<: *kafka-env
      KAFKA_BROKER_ID: '3'
      KAFKA_LISTENERS: CONTROLLER://broker3:19091,INTERNAL://broker3:29091,EXTERNAL://broker3:39091,TOKEN://broker3:49091
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://broker3:29091,EXTERNAL://broker3:39091,TOKEN://broker3:49091
      KAFKA_CONFLUENT_METADATA_SERVER_ADVERTISED_LISTENERS: https://broker3:8091

  init_permissions:
    image: confluentinc/cp-server:${CONFLUENT_DOCKER_TAG:-latest}
    container_name: init_permissions
    depends_on:
      broker3:
        condition: service_healthy
    networks:
      - my-network
    entrypoint: /bin/bash
    command: "/usr/bin/init_permissions.sh"
#    command: ["sh", "-c", "while true; do sleep 3600; done"]
    restart: no
    volumes:
      - ./certs/ca/ca.crt:/certs/ca.crt
      - ../src/adapter/src/main/resources/certs/cert.pem:/certs/cert.pem
      - ../src/adapter/src/main/resources/certs/key.pem:/certs/key.pem
      - ./scripts/helper/init_permissions.sh:/usr/bin/init_permissions.sh
      - ./kafka/configs:/etc/confluent/configs
    environment:
      SUPERUSER_CLIENT_ID: ${SUPERUSER_CLIENT_ID}
      SUPERUSER_CLIENT_SECRET: ${SUPERUSER_CLIENT_SECRET}
      SSO_SUPER_USER_GROUP: ${SSO_SUPER_USER_GROUP}
      SR_CLIENT_ID: ${SR_CLIENT_ID}
      CONNECT_CLIENT_ID: ${CONNECT_CLIENT_ID}
      CONNECT_SECRET_PROTECTION_CLIENT_ID: ${CONNECT_SECRET_PROTECTION_CLIENT_ID}
      KSQL_CLIENT_ID: ${KSQL_CLIENT_ID}
      C3_CLIENT_ID: ${C3_CLIENT_ID}
      CLIENT_APP_ID: ${CLIENT_APP_ID}
      IDP_TOKEN_ENDPOINT: ${IDP_TOKEN_ENDPOINT}

  # --------- Schema Registry ---------
  schema-registry1_certgen:
    build: ./certs
    container_name: schema-registry1_certgen
    networks:
      - my-network
    entrypoint: [ "sh", "/app/generate_cert.sh" ]
    restart: no
    volumes:
      - ./scripts/helper/generate_cert.sh:/app/generate_cert.sh
      - ./certs/ca:/ca
      - ./kafka/schema-registry1/certs:/schema-registry1
    environment:
      - MAIN_DOMAIN=schema-registry1
      - CERT_PASSWORD=${CERT_SECRET}

  schema-registry1:
    image: confluentinc/cp-schema-registry:${CONFLUENT_DOCKER_TAG:-latest}
    container_name: schema-registry1
    depends_on:
      broker3:
        condition: service_healthy
      schema-registry1_certgen:
        condition: service_completed_successfully
      init_permissions:
        condition: service_completed_successfully
    ports:
      - "8081:8081"
      - "1237:1234"
    networks:
      - my-network
#    command: ["sh", "-c", "while true; do sleep 3600; done"]
    healthcheck:
      test: >
        sh -c 'curl --silent --insecure -o /dev/null -w "%{http_code}" https://localhost:8081/subject | grep -E "^(200|401)$" > /dev/null'
      start_period: 10s
      interval: 10s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    volumes:
      - ./kafka/keypair:/tmp/conf
      - ./kafka/broker1/certs:/tmp/kafka/certs
      - ./kafka/schema-registry1/certs:/etc/schema-registry/secrets
      - ./kafka/configs:/etc/confluent/configs
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/cp-base-new/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/cp-base-new/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/cp-base-new/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/nimbus-jose-jwt-9.37.2.jar:/usr/share/java/cp-base-new/nimbus-jose-jwt-9.37.2.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/confluent-security/schema-registry/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/confluent-security/schema-registry/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/confluent-security/schema-registry/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/confluent-security/schema-validator/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/confluent-security/schema-validator/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/confluent-security/schema-validator/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/confluent-control-center/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/confluent-control-center/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/confluent-control-center/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/confluent-telemetry/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/confluent-telemetry/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/confluent-telemetry/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/confluent-common/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/confluent-common/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/confluent-common/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/monitoring-interceptors/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/monitoring-interceptors/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/monitoring-interceptors/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/rest-utils/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/rest-utils/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/rest-utils/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/kafka-serde-tools/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/kafka-serde-tools/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/kafka-serde-tools/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/acl/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/acl/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/acl/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/schema-registry/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/schema-registry/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/schema-registry/kafka-oauth-client-0.15.1.jar
      - ./kafka/libs/kafka-oauth-common-0.15.1.jar:/usr/share/java/schema-registry-plugins/kafka-oauth-common-0.15.1.jar
      - ./kafka/libs/kafka-oauth-server-0.15.1.jar:/usr/share/java/schema-registry-plugins/kafka-oauth-server-0.15.1.jar
      - ./kafka/libs/kafka-oauth-client-0.15.1.jar:/usr/share/java/schema-registry-plugins/kafka-oauth-client-0.15.1.jar
      - ./kafka/bin/confluent:/usr/bin/confluent
      - ./kafka/bin/jmx_prometheus_javaagent.jar:/usr/bin/jmx/jmx_prometheus_javaagent.jar
      - ./kafka/metrics/exporter.yml:/usr/bin/jmx/exporter.yml
    environment:
      SCHEMA_REGISTRY_CLUSTER_ID: "schema-registry-cluster"
      SCHEMA_REGISTRY_GROUP_ID: "schema-registry-group"
      SCHEMA_REGISTRY_HOST_NAME: schema-registry1
      SCHEMA_REGISTRY_KAFKASTORE_TOPIC: _schemas
      SCHEMA_REGISTRY_LISTENERS: https://0.0.0.0:8081
      SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS: broker1:59091,broker2:59091,broker3:59091

      SCHEMA_REGISTRY_LOG4J_ROOT_LOGLEVEL: INFO

      # Encryption
      SCHEMA_REGISTRY_INTER_INSTANCE_PROTOCOL: 'https'
      SCHEMA_REGISTRY_SCHEMA_REGISTRY_INTER_INSTANCE_PROTOCOL: 'https'
      SCHEMA_REGISTRY_SSL_CLIENT_AUTHENTICATION: 'REQUIRED'
      SCHEMA_REGISTRY_SSL_KEYSTORE_TYPE: PKCS12
      SCHEMA_REGISTRY_SSL_KEYSTORE_LOCATION: /etc/schema-registry/secrets/keystore.p12
      SCHEMA_REGISTRY_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
      SCHEMA_REGISTRY_SSL_KEY_PASSWORD: ${CERT_SECRET}
      SCHEMA_REGISTRY_SSL_TRUSTSTORE_TYPE: PKCS12
      SCHEMA_REGISTRY_SSL_TRUSTSTORE_LOCATION: /etc/schema-registry/secrets/truststore.p12
      SCHEMA_REGISTRY_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
      SCHEMA_REGISTRY_SSL_CIPHER_SUITES: ${SSL_CIPHER_SUITES}

      # Schema store
      SCHEMA_REGISTRY_KAFKASTORE_TIMEOUT_MS: 10000
      SCHEMA_REGISTRY_KAFKASTORE_INIT_TIMEOUT_MS: 120000
      SCHEMA_REGISTRY_KAFKASTORE_SECURITY_PROTOCOL: SASL_SSL
      SCHEMA_REGISTRY_KAFKASTORE_SASL_MECHANISM: OAUTHBEARER
#      SCHEMA_REGISTRY_KAFKASTORE_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
      #            ssl.endpoint.identification.algorithm="https" \
      #            ssl.keystore.type="PKCS12" \
      #            ssl.keystore.location="/etc/schema-registry/secrets/keystore.p12" \
      #            ssl.keystore.password="${CERT_SECRET}" \
      #            ssl.key.password="${CERT_SECRET}"  \
      SCHEMA_REGISTRY_KAFKASTORE_SASL_JAAS_CONFIG: |
        org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
            oauth.client.id="${SR_CLIENT_ID}" \
            oauth.client.secret="${SR_CLIENT_SECRET}" \
            oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
            principalClaimName="sub" \
            refresh_ms="3000" \
            oauth.ssl.truststore.type="PKCS12" \
            oauth.ssl.truststore.location="/etc/schema-registry/secrets/truststore.p12" \
            oauth.ssl.truststore.password="${CERT_SECRET}";
      SCHEMA_REGISTRY_KAFKASTORE_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
      SCHEMA_REGISTRY_KAFKASTORE_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
      SCHEMA_REGISTRY_KAFKASTORE_UPDATE_HANDLERS: io.confluent.schema.exporter.storage.SchemaExporterUpdateHandler

      SCHEMA_REGISTRY_KAFKASTORE_SSL_KEYSTORE_TYPE: PKCS12
      SCHEMA_REGISTRY_KAFKASTORE_SSL_KEYSTORE_LOCATION: /etc/schema-registry/secrets/keystore.p12
      SCHEMA_REGISTRY_KAFKASTORE_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
      SCHEMA_REGISTRY_KAFKASTORE_SSL_KEY_PASSWORD: ${CERT_SECRET}
      SCHEMA_REGISTRY_KAFKASTORE_SSL_TRUSTSTORE_TYPE: PKCS12
      SCHEMA_REGISTRY_KAFKASTORE_SSL_TRUSTSTORE_LOCATION: /etc/schema-registry/secrets/truststore.p12
      SCHEMA_REGISTRY_KAFKASTORE_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}

      # authentication/authroization of rest endpoint
      SCHEMA_REGISTRY_RESOURCE_EXTENSION_CLASS: io.confluent.kafka.schemaregistry.security.SchemaRegistrySecurityResourceExtension, io.confluent.schema.exporter.SchemaExporterResourceExtension
      SCHEMA_REGISTRY_CONFLUENT_SCHEMA_REGISTRY_AUTHORIZER_CLASS: io.confluent.kafka.schemaregistry.security.authorizer.rbac.RbacAuthorizer
      SCHEMA_REGISTRY_REST_SERVLET_INITIALIZOR_CLASSES: io.confluent.common.security.jetty.initializer.AuthenticationHandler
      SCHEMA_REGISTRY_CONFLUENT_SCHEMA_REGISTRY_AUTH_MECHANISM: JETTY_AUTH
      SCHEMA_REGISTRY_PUBLIC_KEY_PATH: /tmp/conf/public.pem
      SCHEMA_REGISTRY_PASSWORD_ENCODER_SECRET: random

      # Authorization through mds
      SCHEMA_REGISTRY_CONFLUENT_METADATA_BASIC_AUTH_USER_INFO: schemaregistryUser:${SR_CLIENT_ID}
      SCHEMA_REGISTRY_CONFLUENT_METADATA_BOOTSTRAP_SERVER_URLS: https://broker1:8091,https://broker2:8091,https://broker3:8091
      SCHEMA_REGISTRY_CONFLUENT_METADATA_HTTP_AUTH_CREDENTIALS_PROVIDER: OAUTHBEARER
      SCHEMA_REGISTRY_CONFLUENT_METADATA_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
      SCHEMA_REGISTRY_CONFLUENT_METADATA_OAUTHBEARER_LOGIN_CLIENT_ID: ${SR_CLIENT_ID}
      SCHEMA_REGISTRY_CONFLUENT_METADATA_OAUTHBEARER_LOGIN_CLIENT_SECRET: ${SR_CLIENT_SECRET}
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_OAUTHBEARER_SASL_JAAS_CONFIG: |
#        org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
#            oauth.client.id="${SR_CLIENT_ID}" \
#            oauth.client.secret="${SR_CLIENT_SECRET}" \
#            oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
#            principalClaimName="sub" \
#            refresh_ms="3000" \
#            ssl.endpoint.identification.algorithm="https" \
#            ssl.keystore.type="PKCS12" \
#            ssl.keystore.location="/etc/schema-registry/secrets/keystore.p12" \
#            ssl.keystore.password="${CERT_SECRET}" \
#            ssl.key.password="${CERT_SECRET}"  \
#            ssl.truststore.type="PKCS12" \
#            ssl.truststore.location="/etc/schema-registry/secrets/truststore.p12" \
#            ssl.truststore.password="${CERT_SECRET}";
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler
#
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_CLIENT_AUTHENTICATION: 'REQUIRED'
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_KEYSTORE_TYPE: PKCS12
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_KEYSTORE_LOCATION: /etc/schema-registry/secrets/truststore.p12
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_KEYSTORE_PASSWORD: ${CERT_SECRET}
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_KEY_PASSWORD: ${CERT_SECRET}
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_TRUSTSTORE_TYPE: PKCS12
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_TRUSTSTORE_LOCATION: /etc/schema-registry/secrets/truststore.p12
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_TRUSTSTORE_PASSWORD: ${CERT_SECRET}
#      SCHEMA_REGISTRY_CONFLUENT_METADATA_SSL_CIPHER_SUITES: ${SSL_CIPHER_SUITES}

      SCHEMA_REGISTRY_OAUTHBEARER_JWKS_ENDPOINT_URL: ${IDP_JWKS_ENDPOINT}
      SCHEMA_REGISTRY_OAUTHBEARER_EXPECTED_ISSUER: ${IDP_EXPECTED_ISSUER}
      SCHEMA_REGISTRY_OAUTHBEARER_EXPECTED_AUDIENCE: ${EXPECTED_AUDIENCE}
      SCHEMA_REGISTRY_OAUTHBEARER_SUB_CLAIM_NAME: ${SUB_CLAIM_NAME}
      SCHEMA_REGISTRY_OAUTHBEARER_GROUPS_CLAIM_NAME: ${GROUP_CLAIM_NAME}
#      SCHEMA_REGISTRY_SASL_MECHANISM: OAUTHBEARER
#      SCHEMA_REGISTRY_SASL_OAUTHBEARER_TOKEN_ENDPOINT_URL: ${IDP_TOKEN_ENDPOINT}
#      SCHEMA_REGISTRY_SASL_JAAS_CONFIG: |
#        org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \
#            oauth.client.id="${SR_CLIENT_ID}" \
#            oauth.client.secret="${SR_CLIENT_SECRET}" \
#            oauth.token.endpoint.uri="${IDP_TOKEN_ENDPOINT}" \
#            principalClaimName="sub" \
#            refresh_ms="3000" \
#            ssl.endpoint.identification.algorithm="https" \
#            ssl.keystore.type="PKCS12" \
#            ssl.keystore.location="/etc/schema-registry/secrets/keystore.p12" \
#            ssl.keystore.password="${CERT_SECRET}" \
#            ssl.key.password="${CERT_SECRET}"  \
#            ssl.truststore.type="PKCS12" \
#            ssl.truststore.location="/etc/schema-registry/secrets/truststore.p12" \
#            ssl.truststore.password="${CERT_SECRET}";
#      SCHEMA_REGISTRY_PRINCIPAL_BUILDER_CLASS: io.strimzi.kafka.oauth.server.OAuthKafkaPrincipalBuilder
#      SCHEMA_REGISTRY_SASL_LOGIN_CALLBACK_HANDLER_CLASS: io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler

#      SCHEMA_REGISTRY_REST_AUTH_JMX_ENABLED: 'true'
#      EXTRA_ARGS: "-javaagent:/usr/bin/jmx/jmx_prometheus_javaagent.jar=1234:/usr/bin/jmx/exporter.yml"
      SCHEMA_REGISTRY_LEADER_ELIGIBILITY: 'true'
      SCHEMA_REGISTRY_MODE_MUTABILITY: 'true'
      SCHEMA_REGISTRY_DEBUG: 'true'
      KAFKA_HEAP_OPTS: "-Xms${SCHEMA_HEAP} -Xmx${SCHEMA_HEAP}"

volumes:
  postgres-data:
    driver: local
  broker1-data:
    driver: local
  broker2-data:
    driver: local
  broker3-data:
    driver: local

networks:
  my-network:
    driver: bridge